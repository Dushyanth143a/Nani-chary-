<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nani's String Art</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Kalnia+Glaze:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .title-font {
            font-family: 'Kalnia Glaze', serif;
        }
        .cropper-view-box.heart-shape,
        .cropper-face.heart-shape {
            clip-path: url(#heart-clip);
            border-radius: 0;
        }
        .loader {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        /* Custom slider styles */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 5px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]:focus::-webkit-slider-runnable-track {
            background: #cbd5e1;
        }
        input[type=range]::-moz-range-track {
            width: 100%;
            height: 8px;
            cursor: pointer;
            background: #e2e8f0;
            border-radius: 5px;
        }
        input[type=range]::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
         /* Hide number input arrows */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
          -webkit-appearance: none; 
          margin: 0; 
        }
        input[type=number] {
          -moz-appearance: textfield;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800">
    <svg width="0" height="0" class="absolute">
      <defs>
        <clipPath id="heart-clip" clipPathUnits="objectBoundingBox">
          <path d="M0.5,1 C0.5,1,0,0.7,0,0.3 A0.25,0.25,1,0,1,0.5,0.3 A0.25,0.25,1,0,1,1,0.3 C1,0.7,0.5,1,0.5,1 Z" />
        </clipPath>
      </defs>
    </svg>

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-5xl md:text-6xl font-bold text-gray-900 title-font">Nani's String Art</h1>
            <p class="text-gray-600 mt-2">Turn your photos into beautiful string art patterns.</p>
        </header>

        <div class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            <!-- Controls Column -->
            <div class="lg:col-span-4 space-y-6">
                <div class="bg-white p-6 rounded-xl shadow-lg">
                    <h3 class="text-lg font-semibold text-gray-700 border-b pb-2 mb-4 flex items-center">
                        <span class="bg-indigo-500 text-white rounded-full h-8 w-8 text-sm flex items-center justify-center mr-3">1</span>
                        Upload & Crop
                    </h3>
                    <input type="file" id="image-upload" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100 cursor-pointer">
                    <div id="image-container" class="mt-4 hidden h-64 bg-gray-100 rounded-lg flex items-center justify-center">
                        <img id="image-to-crop" class="max-h-full">
                    </div>
                </div>
                
                <div id="controls-panel" class="bg-white p-6 rounded-xl shadow-lg space-y-6 hidden">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 border-b pb-2 mb-4 flex items-center">
                            <span class="bg-indigo-500 text-white rounded-full h-8 w-8 text-sm flex items-center justify-center mr-3">2</span>
                            Shape & Dimensions
                        </h3>
                        <div class="mb-4">
                            <label class="block text-sm font-medium text-gray-600 mb-2">Shape</label>
                            <div class="grid grid-cols-2 gap-2">
                                <button id="shape-circle" class="shape-btn border-2 border-indigo-500 bg-indigo-100 text-indigo-700 p-2 rounded-lg font-semibold">Circle</button>
                                <button id="shape-square" class="shape-btn border-2 border-gray-300 p-2 rounded-lg font-semibold text-gray-600">Square</button>
                            </div>
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-gray-600 mb-2">Physical Size (inches)</label>
                            <div class="flex items-center space-x-2">
                                <input type="number" id="physical-width" value="12" class="w-full p-2 border border-gray-300 rounded-lg text-center">
                                <span class="text-gray-500">x</span>
                                <input type="number" id="physical-height" value="12" class="w-full p-2 border border-gray-300 rounded-lg text-center">
                            </div>
                        </div>
                    </div>

                    <div>
                        <h3 class="text-lg font-semibold text-gray-700 border-b pb-2 mb-4 flex items-center">
                             <span class="bg-indigo-500 text-white rounded-full h-8 w-8 text-sm flex items-center justify-center mr-3">3</span>
                            Art Configuration
                        </h3>
                        <div class="space-y-4">
                            <div>
                                <label for="pins-input" class="flex justify-between items-center text-sm font-medium text-gray-600">
                                    <span>Pins</span>
                                    <input type="number" id="pins-input" min="100" max="500" value="250" class="w-20 p-1 border border-gray-300 rounded-md text-center">
                                </label>
                                <input type="range" id="pins-slider" min="100" max="500" value="250" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1">
                            </div>
                            <div>
                                <label for="lines-input" class="flex justify-between items-center text-sm font-medium text-gray-600">
                                    <span>Lines</span>
                                    <input type="number" id="lines-input" min="500" max="8000" value="3000" class="w-20 p-1 border border-gray-300 rounded-md text-center">
                                </label>
                                <input type="range" id="lines-slider" min="500" max="8000" value="3000" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mt-1">
                            </div>
                        </div>
                    </div>

                    <button id="generate-btn" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition-colors flex items-center justify-center">
                        <svg id="generate-icon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M11.3 1.046A1 1 0 0112 2v5h4a1 1 0 01.82 1.573l-7 10A1 1 0 018 18v-5H4a1 1 0 01-.82-1.573l7-10a1 1 0 011.12-.38z" clip-rule="evenodd" /></svg>
                        <span id="generate-text">Generate Art</span>
                        <div id="loader" class="loader ease-linear rounded-full border-4 border-t-4 border-gray-200 h-6 w-6 hidden ml-2"></div>
                    </button>
                </div>
            </div>

            <!-- Output Column -->
            <div class="lg:col-span-8">
                 <div id="output-container" class="bg-white p-6 rounded-xl shadow-lg h-full hidden">
                    <h3 class="text-lg font-semibold text-gray-700 border-b pb-2 mb-4">Preview & Results</h3>
                    
                    <div class="flex justify-center items-center bg-gray-100 rounded-lg" style="min-height: 400px; max-height: 500px;">
                        <canvas id="preview-canvas" class="max-w-full max-h-full"></canvas>
                    </div>

                    <!-- Preview Controls -->
                    <div id="preview-controls" class="flex flex-col items-center justify-center mt-4 hidden">
                        <div class="flex items-center justify-center space-x-2 md:space-x-4">
                            <button id="reset-preview-btn" title="Reset" class="p-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M4 4v5h5M20 20v-5h-5" />
                                  <path stroke-linecap="round" stroke-linejoin="round" d="M4 9a9 9 0 0114.13-5.12M20 15a9 9 0 01-14.13 5.12" />
                                </svg>
                            </button>
                            <button id="step-backward-btn" title="Step Backward" class="p-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                                  <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button id="play-pause-btn" title="Play/Pause Animation" class="p-2 bg-indigo-600 text-white font-semibold rounded-lg hover:bg-indigo-700 transition-colors">
                                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M6.32 5.013C5.587 4.51 4.75 5.025 4.75 5.85v8.3a.85.85 0 001.57.513l8.14-4.15a.85.85 0 000-1.526L6.32 5.013z" />
                                </svg>
                                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M5.75 4.5a.75.75 0 00-.75.75v10.5a.75.75 0 001.5 0V5.25a.75.75 0 00-.75-.75zm8.5 0a.75.75 0 00-.75.75v10.5a.75.75 0 001.5 0V5.25a.75.75 0 00-.75-.75z" />
                                </svg>
                            </button>
                            <button id="step-forward-btn" title="Step Forward" class="p-2 bg-gray-200 text-gray-700 font-semibold rounded-lg hover:bg-gray-300 transition-colors">
                               <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                                 <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                                </svg>
                            </button>
                            <button id="speak-btn" title="Speak Instructions" class="p-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition-colors">
                                <svg id="speak-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M13 2.625a.75.75 0 01.494.686v13.378a.75.75 0 01-1.488.172l-3.375-5.062H4.5a.75.75 0 01-.75-.75V8.963a.75.75 0 01.75-.75h4.131l3.375-5.063a.75.75 0 01.994-.172zM15 8.25a.75.75 0 01.75.75v2a.75.75 0 01-1.5 0v-2a.75.75 0 01.75-.75zm2.25.75a.75.75 0 00-1.5 0v2a.75.75 0 001.5 0v-2z" />
                                </svg>
                                <svg id="stop-icon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 hidden" viewBox="0 0 20 20" fill="currentColor">
                                  <path d="M5.25 5.25A.75.75 0 004.5 6v8a.75.75 0 00.75.75h8a.75.75 0 00.75-.75V6a.75.75 0 00-.75-.75h-8z" />
                                </svg>
                            </button>
                        </div>
                        <div id="pin-display" class="text-center text-gray-600 font-mono mt-2 h-6"></div>
                        <div id="time-display" class="text-center text-gray-500 text-sm h-5"></div>
                        <div class="w-full max-w-xs mt-2">
                            <label for="delay-slider" class="flex justify-between text-sm font-medium text-gray-600"><span>Audio Delay</span><span id="delay-value">1000 ms</span></label>
                            <input type="range" id="delay-slider" min="0" max="5000" value="1000" step="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <div id="results-actions" class="hidden mt-6">
                        <div class="mb-4">
                            <h4 class="font-semibold text-gray-600 mb-2">Step-by-Step Instructions</h4>
                            <textarea id="instructions-text" rows="5" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50 font-mono text-sm" readonly></textarea>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <button id="download-txt-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors">Download Instructions (.txt)</button>
                            <button id="download-pdf-btn" class="w-full bg-blue-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-blue-700 transition-colors">Download Pin Template (.pdf)</button>
                        </div>
                    </div>
                 </div>
                 <div id="placeholder-output" class="bg-white p-6 rounded-xl shadow-lg h-full flex flex-col items-center justify-center text-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-24 w-24 text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                      <path stroke-linecap="round" stroke-linejoin="round" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <h3 class="mt-4 text-xl font-semibold text-gray-700">Your artwork will appear here</h3>
                    <p class="text-gray-500 mt-1">Follow the steps on the left to get started.</p>
                 </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const imageUpload = document.getElementById('image-upload');
            const imageContainer = document.getElementById('image-container');
            const imageToCrop = document.getElementById('image-to-crop');
            const controlsPanel = document.getElementById('controls-panel');
            const outputContainer = document.getElementById('output-container');
            const placeholderOutput = document.getElementById('placeholder-output');
            const generateBtn = document.getElementById('generate-btn');
            const loader = document.getElementById('loader');
            const generateText = document.getElementById('generate-text');
            const generateIcon = document.getElementById('generate-icon');
            const shapeCircleBtn = document.getElementById('shape-circle');
            const shapeSquareBtn = document.getElementById('shape-square');
            const physicalWidthInput = document.getElementById('physical-width');
            const physicalHeightInput = document.getElementById('physical-height');
            const pinsSlider = document.getElementById('pins-slider');
            const pinsInput = document.getElementById('pins-input');
            const linesSlider = document.getElementById('lines-slider');
            const linesInput = document.getElementById('lines-input');
            const previewCanvas = document.getElementById('preview-canvas');
            const instructionsText = document.getElementById('instructions-text');
            const resultsActions = document.getElementById('results-actions');
            const downloadTxtBtn = document.getElementById('download-txt-btn');
            const downloadPdfBtn = document.getElementById('download-pdf-btn');
            
            // Preview Controls DOM Elements
            const previewControls = document.getElementById('preview-controls');
            const resetPreviewBtn = document.getElementById('reset-preview-btn');
            const stepBackwardBtn = document.getElementById('step-backward-btn');
            const playPauseBtn = document.getElementById('play-pause-btn');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const stepForwardBtn = document.getElementById('step-forward-btn');
            const pinDisplay = document.getElementById('pin-display');
            const timeDisplay = document.getElementById('time-display');
            const speakBtn = document.getElementById('speak-btn');
            const speakIcon = document.getElementById('speak-icon');
            const stopIcon = document.getElementById('stop-icon');
            const delaySlider = document.getElementById('delay-slider');
            const delayValue = document.getElementById('delay-value');

            // State
            let cropper;
            let currentShape = 'circle';
            let generatedPattern = [];
            let pinCoordsForPreview = [];
            
            // Preview State
            let animationFrameId = null;
            let isPreviewPlaying = false;
            let isSpeaking = false;
            let speechTimeoutId = null;
            let countdownIntervalId = null;
            let currentLineIndex = 0;

            // --- Cropper.js Initialization ---
            const initCropper = () => {
                if (cropper) {
                    cropper.destroy();
                }
                cropper = new Cropper(imageToCrop, {
                    aspectRatio: 1,
                    viewMode: 1,
                    dragMode: 'move',
                    background: false,
                    autoCropArea: 0.8,
                    ready: function () {
                        // This function is called when the cropper is ready.
                        updateCropperShape();
                    },
                });
            };
            
            const updateCropperShape = () => {
                const cropperViewBox = document.querySelector('.cropper-view-box');
                const cropperFace = document.querySelector('.cropper-face');
                if (!cropperViewBox || !cropperFace) return;
                
                physicalHeightInput.disabled = false;
                if (currentShape === 'circle') {
                    physicalHeightInput.value = physicalWidthInput.value;
                }

                // Direct style manipulation for reliability
                cropperViewBox.style.borderRadius = '';
                cropperFace.style.borderRadius = '';
                cropperViewBox.style.clipPath = '';
                cropperFace.style.clipPath = '';

                if (currentShape === 'circle') {
                    cropperViewBox.style.borderRadius = '50%';
                    cropperFace.style.borderRadius = '50%';
                } else if (currentShape === 'heart') {
                    cropperViewBox.style.clipPath = 'url(#heart-clip)';
                    cropperFace.style.clipPath = 'url(#heart-clip)';
                }
            };

            // --- Event Listeners ---
            imageUpload.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        imageToCrop.src = event.target.result;
                        imageContainer.classList.remove('hidden');
                        controlsPanel.classList.remove('hidden');
                        outputContainer.classList.add('hidden');
                        placeholderOutput.classList.remove('hidden');
                        initCropper();
                    };
                    reader.readAsDataURL(file);
                }
            });

            [shapeCircleBtn, shapeSquareBtn].forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.shape-btn').forEach(b => {
                        b.classList.remove('border-indigo-500', 'bg-indigo-100', 'text-indigo-700');
                        b.classList.add('border-gray-300', 'text-gray-600');
                    });
                    btn.classList.add('border-indigo-500', 'bg-indigo-100', 'text-indigo-700');
                    btn.classList.remove('border-gray-300', 'text-gray-600');
                    currentShape = btn.id.split('-')[1];
                    updateCropperShape();
                });
            });
            
            physicalWidthInput.addEventListener('input', (e) => {
                if(currentShape === 'circle') {
                    physicalHeightInput.value = e.target.value;
                }
            });

            physicalHeightInput.addEventListener('input', (e) => {
                if(currentShape === 'circle') {
                    physicalWidthInput.value = e.target.value;
                }
            });

            pinsSlider.addEventListener('input', (e) => pinsInput.value = e.target.value);
            pinsInput.addEventListener('input', (e) => pinsSlider.value = e.target.value);
            linesSlider.addEventListener('input', (e) => linesInput.value = e.target.value);
            linesInput.addEventListener('input', (e) => linesSlider.value = e.target.value);
            delaySlider.addEventListener('input', (e) => delayValue.textContent = `${e.target.value} ms`);

            generateBtn.addEventListener('click', () => {
                if (!cropper) return;
                setTimeout(processAndGenerate, 10); 
            });

            downloadTxtBtn.addEventListener('click', downloadInstructions);
            downloadPdfBtn.addEventListener('click', downloadPdfTemplate);
            
            playPauseBtn.addEventListener('click', togglePlayPause);
            resetPreviewBtn.addEventListener('click', resetPreview);
            stepForwardBtn.addEventListener('click', stepForward);
            stepBackwardBtn.addEventListener('click', stepBackward);
            speakBtn.addEventListener('click', toggleSpeaking);

            // --- Helper Functions ---
            function getPinLabel(pinIndex) {
                const groupIndex = Math.floor(pinIndex / 10);
                const pinInGroup = (pinIndex % 10) + 1;
                const groupLetter = String.fromCharCode('A'.charCodeAt(0) + groupIndex);
                return `${groupLetter}${pinInGroup}`;
            }

            function getPinLabelForPdf(pinIndex) {
                const pinInGroup = pinIndex % 10;
                if (pinInGroup === 0) {
                    return getPinLabel(pinIndex);
                } else {
                    return (pinInGroup + 1).toString();
                }
            }

            // --- Core Logic ---
            async function processAndGenerate() {
                setLoading(true);

                const numPins = parseInt(pinsInput.value);
                const numLines = parseInt(linesInput.value);
                
                const croppedCanvas = cropper.getCroppedCanvas({ width: 500, height: 500, imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                const ctx = croppedCanvas.getContext('2d', { willReadFrequently: true });
                const imageData = processImage(ctx, croppedCanvas.width, croppedCanvas.height);
                
                pinCoordsForPreview = getPinCoordinates(currentShape, croppedCanvas.width, croppedCanvas.height, numPins, 15);
                generatedPattern = await runStringArtAlgorithm(imageData, pinCoordsForPreview, numLines);

                displayFinalResult();
                displayInstructions(generatedPattern, numPins, numLines);

                outputContainer.classList.remove('hidden');
                placeholderOutput.classList.add('hidden');
                resultsActions.classList.remove('hidden');
                
                setLoading(false);
            }

            function setLoading(isLoading) {
                generateBtn.disabled = isLoading;
                loader.classList.toggle('hidden', !isLoading);
                generateIcon.classList.toggle('hidden', isLoading);
                generateText.textContent = isLoading ? 'Generating...' : 'Generate Art';
            }

            function processImage(ctx, width, height) {
                ctx.globalCompositeOperation = 'destination-in';
                ctx.fillStyle = '#000';
                ctx.beginPath();
                if (currentShape === 'circle') {
                    ctx.arc(width / 2, height / 2, width / 2, 0, Math.PI * 2);
                } else if (currentShape === 'heart') {
                    const heartPath = getPinCoordinates('heart', width, height, 200, 0);
                    ctx.moveTo(heartPath[0].x, heartPath[0].y);
                    for(let i = 1; i < heartPath.length; i++) {
                        ctx.lineTo(heartPath[i].x, heartPath[i].y);
                    }
                    ctx.closePath();
                } else {
                    ctx.rect(0, 0, width, height);
                }
                ctx.fill();
                ctx.globalCompositeOperation = 'source-over';

                const imageData = ctx.getImageData(0, 0, width, height);
                const data = imageData.data;
                for (let i = 0; i < data.length; i += 4) {
                    const avg = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
                    const inverted = 255 - avg;
                    data[i] = data[i + 1] = data[i + 2] = inverted;
                }
                return imageData;
            }
            
            function getPinCoordinates(shape, width, height, numPins, padding = 0) {
                const coords = [];
                const drawWidth = width - padding * 2;
                const drawHeight = height - padding * 2;
                const centerX = drawWidth / 2;
                const centerY = drawHeight / 2;

                if (shape === 'circle') {
                    const radius = drawWidth / 2;
                    for (let i = 0; i < numPins; i++) {
                        const angle = (i / numPins) * 2 * Math.PI;
                        coords.push({
                            x: centerX + radius * Math.cos(angle) + padding,
                            y: centerY + radius * Math.sin(angle) + padding
                        });
                    }
                } else if (shape === 'square') {
                    const perimeter = drawWidth * 4;
                    for (let i = 0; i < numPins; i++) {
                        let dist = (i / numPins) * perimeter;
                        if (dist < drawWidth) { // Top edge
                            coords.push({ x: dist + padding, y: padding });
                        } else if (dist < drawWidth * 2) { // Right edge
                            coords.push({ x: drawWidth + padding, y: (dist - drawWidth) + padding });
                        } else if (dist < drawWidth * 3) { // Bottom edge
                            coords.push({ x: (drawWidth - (dist - drawWidth * 2)) + padding, y: drawHeight + padding });
                        } else { // Left edge
                            coords.push({ x: padding, y: (drawHeight - (dist - drawWidth * 3)) + padding });
                        }
                    }
                } else if (shape === 'heart') {
                    // Parametric equation for a heart
                    for (let i = 0; i < numPins; i++) {
                        const t = (i / numPins) * 2 * Math.PI;
                        const scale = drawWidth / 32; // Scale factor
                        const x = centerX + scale * 16 * Math.pow(Math.sin(t), 3);
                        const y = centerY - scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                        coords.push({ x: x + padding, y: y + padding });
                    }
                }
                return coords;
            }

            function runStringArtAlgorithm(imageData, pinCoords, numLines) {
                return new Promise(resolve => {
                    const width = imageData.width;
                    const data = new Uint8ClampedArray(imageData.data);
                    const pattern = [];
                    let currentPin = 0;

                    function* algorithmGenerator() {
                        for (let lineNum = 0; lineNum < numLines; lineNum++) {
                            let bestNextPin = -1, maxDarkness = -1;
                            for (let nextPin = 0; nextPin < pinCoords.length; nextPin++) {
                                if (nextPin === currentPin) continue;
                                let p1 = pinCoords[currentPin], p2 = pinCoords[nextPin];
                                let currentDarkness = 0, pixelCount = 0;
                                let x0 = Math.floor(p1.x), y0 = Math.floor(p1.y);
                                const x1 = Math.floor(p2.x), y1 = Math.floor(p2.y);
                                const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
                                const dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
                                let err = dx + dy, e2;
                                while (true) {
                                    const index = (y0 * width + x0) * 4;
                                    if (index >= 0 && index < data.length) {
                                        currentDarkness += data[index];
                                        pixelCount++;
                                    }
                                    if (x0 === x1 && y0 === y1) break;
                                    e2 = 2 * err;
                                    if (e2 >= dy) { err += dy; x0 += sx; }
                                    if (e2 <= dx) { err += dx; y0 += sy; }
                                }
                                const avgDarkness = pixelCount > 0 ? currentDarkness / pixelCount : 0;
                                if (avgDarkness > maxDarkness) {
                                    maxDarkness = avgDarkness;
                                    bestNextPin = nextPin;
                                }
                            }
                            if (bestNextPin !== -1) {
                                pattern.push({ from: currentPin, to: bestNextPin });
                                let p1 = pinCoords[currentPin], p2 = pinCoords[bestNextPin];
                                let x0 = Math.floor(p1.x), y0 = Math.floor(p1.y);
                                const x1 = Math.floor(p2.x), y1 = Math.floor(p2.y);
                                const dx = Math.abs(x1 - x0), sx = x0 < x1 ? 1 : -1;
                                const dy = -Math.abs(y1 - y0), sy = y0 < y1 ? 1 : -1;
                                let err = dx + dy, e2;
                                while (true) {
                                    const index = (y0 * width + x0) * 4;
                                    if (index >= 0 && index < data.length) {
                                        data[index] = data[index + 1] = data[index + 2] = Math.max(0, data[index] - 30);
                                    }
                                    if (x0 === x1 && y0 === y1) break;
                                    e2 = 2 * err;
                                    if (e2 >= dy) { err += dy; x0 += sx; }
                                    if (e2 <= dx) { err += dx; y0 += sy; }
                                }
                                currentPin = bestNextPin;
                            }
                            yield;
                        }
                        resolve(pattern);
                    }
                    const generator = algorithmGenerator();
                    function run() {
                        if (!generator.next().done) requestAnimationFrame(run);
                    }
                    run();
                });
            }
            
            // --- Preview Functions ---
            function updatePinDisplay(index) {
                if (index > 0 && index <= generatedPattern.length) {
                    const line = generatedPattern[index - 1];
                    pinDisplay.textContent = `Step ${index}: Pin ${getPinLabel(line.from)} â†’ Pin ${getPinLabel(line.to)}`;
                } else if (index > generatedPattern.length) {
                    pinDisplay.textContent = 'Finished';
                }
                else {
                    pinDisplay.textContent = '';
                }
            }

            function stopAllPreviews() {
                pausePreview();
                stopSpeaking();
            }

            function resetAnimationState() {
                stopAllPreviews();
                currentLineIndex = 0;
                playPauseBtn.disabled = false;
                speakBtn.disabled = false;
                updatePinDisplay(0);
            }

            function displayFinalResult() {
                resetAnimationState();
                redrawUpTo(generatedPattern.length);
                pinDisplay.textContent = 'Completed Pattern';
                previewControls.classList.remove('hidden');
            }

            function redrawUpTo(endIndex) {
                const ctx = previewCanvas.getContext('2d');
                previewCanvas.width = 500;
                previewCanvas.height = 500;
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 500, 500);

                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.lineWidth = 0.5;
                for (let i = 0; i < endIndex; i++) {
                    const line = generatedPattern[i];
                    const from = pinCoordsForPreview[line.from];
                    const to = pinCoordsForPreview[line.to];
                    if (from && to) {
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                    }
                }

                ctx.fillStyle = 'red';
                if (pinCoordsForPreview && pinCoordsForPreview.length > 0) {
                    pinCoordsForPreview.forEach(pin => {
                        ctx.beginPath();
                        ctx.arc(pin.x, pin.y, 2, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
            }

            function togglePlayPause() {
                stopSpeaking();
                if (isPreviewPlaying) {
                    pausePreview();
                } else {
                    playPreview();
                }
            }

            function playPreview() {
                if (isPreviewPlaying) return;
                
                if (currentLineIndex >= generatedPattern.length) {
                    currentLineIndex = 0;
                }
                                
                redrawUpTo(currentLineIndex);

                isPreviewPlaying = true;
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
                animatePreview();
            }

            function pausePreview() {
                isPreviewPlaying = false;
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }

            function resetPreview() {
                displayFinalResult();
            }

            function stepForward() {
                stopAllPreviews();
                if (currentLineIndex < generatedPattern.length) {
                    currentLineIndex++;
                    redrawUpTo(currentLineIndex);
                    updatePinDisplay(currentLineIndex);
                }
            }

            function stepBackward() {
                stopAllPreviews();
                if (currentLineIndex > 0) {
                    currentLineIndex--;
                    redrawUpTo(currentLineIndex);
                    updatePinDisplay(currentLineIndex);
                }
            }

            function animatePreview() {
                if (!isPreviewPlaying) return;

                if (currentLineIndex >= generatedPattern.length) {
                    pausePreview();
                    playPauseBtn.disabled = true;
                    updatePinDisplay(currentLineIndex + 1);
                    return;
                }
                const ctx = previewCanvas.getContext('2d');
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.lineWidth = 0.5;
                const linesPerFrame = Math.max(1, Math.floor(generatedPattern.length / 300));
                const endLine = Math.min(currentLineIndex + linesPerFrame, generatedPattern.length);
                for (let i = currentLineIndex; i < endLine; i++) {
                    const line = generatedPattern[i];
                    const from = pinCoordsForPreview[line.from];
                    const to = pinCoordsForPreview[line.to];
                    if (from && to) {
                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                    }
                }
                currentLineIndex = endLine;
                updatePinDisplay(currentLineIndex);
                animationFrameId = requestAnimationFrame(animatePreview);
            }

            // --- Speech Synthesis Functions ---
            function formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;
                return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            }

            function toggleSpeaking() {
                if (isSpeaking) {
                    stopSpeaking();
                } else {
                    startSpeaking();
                }
            }

            function startSpeaking() {
                pausePreview(); // Stop canvas animation
                if (currentLineIndex >= generatedPattern.length) {
                    currentLineIndex = 0;
                }
                isSpeaking = true;
                speakIcon.classList.add('hidden');
                stopIcon.classList.remove('hidden');
                delaySlider.disabled = true;

                // Start countdown
                const remainingSteps = generatedPattern.length - currentLineIndex;
                const delay = parseInt(delaySlider.value);
                const avgSpeechTime = 1500; // Estimated avg time to speak a line in ms
                let remainingSeconds = Math.round((remainingSteps * (delay + avgSpeechTime)) / 1000);
                
                if (countdownIntervalId) clearInterval(countdownIntervalId);
                countdownIntervalId = setInterval(() => {
                    if (remainingSeconds >= 0) {
                        timeDisplay.textContent = `Est. Time: ${formatTime(remainingSeconds)}`;
                        remainingSeconds--;
                    } else {
                        clearInterval(countdownIntervalId);
                    }
                }, 1000);

                speakLoop();
            }

            function stopSpeaking() {
                isSpeaking = false;
                speechSynthesis.cancel();
                if (speechTimeoutId) clearTimeout(speechTimeoutId);
                if (countdownIntervalId) clearInterval(countdownIntervalId);
                speakIcon.classList.remove('hidden');
                stopIcon.classList.add('hidden');
                delaySlider.disabled = false;
                timeDisplay.textContent = '';
            }

            async function speakLoop() {
                if (!isSpeaking || currentLineIndex >= generatedPattern.length) {
                    stopSpeaking();
                    updatePinDisplay(currentLineIndex);
                    if(currentLineIndex >= generatedPattern.length) {
                         pinDisplay.textContent = 'Finished';
                    }
                    return;
                }

                currentLineIndex++;
                redrawUpTo(currentLineIndex);
                updatePinDisplay(currentLineIndex);
                
                const line = generatedPattern[currentLineIndex - 1];
                const textToSpeak = `Pin ${getPinLabel(line.from).split('').join(' ')} to ${getPinLabel(line.to).split('').join(' ')}`;
                const utterance = new SpeechSynthesisUtterance(textToSpeak);

                await new Promise(resolve => {
                    utterance.onend = resolve;
                    speechSynthesis.speak(utterance);
                });

                if (isSpeaking) { // Check again in case stop was pressed during speech
                    const delay = parseInt(delaySlider.value);
                    speechTimeoutId = setTimeout(speakLoop, delay);
                }
            }


            function displayInstructions(pattern, numPins, numLines) {
                let instructions = `String Art Pattern\nShape: ${currentShape}\nPins: ${numPins}\nLines: ${numLines}\n\nPin Connections:\n`;
                pattern.forEach((line, index) => {
                    instructions += `${index + 1}. ${getPinLabel(line.from)} -> ${getPinLabel(line.to)}\n`;
                });
                instructionsText.value = instructions;
            }

            function downloadInstructions() {
                const blob = new Blob([instructionsText.value], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'string-art-instructions.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function downloadPdfTemplate() {
                const { jsPDF } = window.jspdf;
                const widthIn = parseFloat(physicalWidthInput.value);
                const heightIn = parseFloat(physicalHeightInput.value);
                const numPins = parseInt(pinsInput.value);
                
                const a4_width_in = 8.27;
                const a4_height_in = 11.69;
                const margin = 0.5;

                const printableWidth = a4_width_in - (margin * 2);
                const printableHeight = a4_height_in - (margin * 2);

                const cols = Math.ceil(widthIn / printableWidth);
                const rows = Math.ceil(heightIn / printableHeight);

                const doc = new jsPDF({ orientation: 'p', unit: 'in', format: 'a4' });

                const pinCoords = getPinCoordinates(currentShape, widthIn, heightIn, numPins, 0.25);

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (r > 0 || c > 0) {
                            doc.addPage();
                        }
                        
                        const offsetX = c * printableWidth;
                        const offsetY = r * printableHeight;

                        doc.setDrawColor(200, 200, 200);
                        doc.setLineWidth(0.01);
                        // Alignment marks
                        doc.line(margin - 0.2, margin, margin + 0.2, margin); // Top
                        doc.line(margin, margin - 0.2, margin, margin + 0.2);
                        doc.line(a4_width_in - margin - 0.2, margin, a4_width_in - margin + 0.2, margin); // Top Right
                        doc.line(a4_width_in - margin, margin - 0.2, a4_width_in - margin, margin + 0.2);
                        doc.line(margin - 0.2, a4_height_in - margin, margin + 0.2, a4_height_in - margin); // Bottom Left
                        doc.line(margin, a4_height_in - margin - 0.2, margin, a4_height_in - margin + 0.2);
                        doc.line(a4_width_in - margin - 0.2, a4_height_in - margin, a4_width_in - margin + 0.2, a4_height_in - margin); // Bottom Right
                        doc.line(a4_width_in - margin, a4_height_in - margin - 0.2, a4_width_in - margin, a4_height_in - margin + 0.2);

                        doc.setDrawColor(180, 180, 180).setLineWidth(0.01);
                        const shapePath = pinCoords.map(p => [p.x + margin - offsetX, p.y + margin - offsetY]);
                        
                        if (shapePath.length > 0) {
                            doc.moveTo(shapePath[0][0], shapePath[0][1]);
                            for (let i = 1; i < shapePath.length; i++) {
                                doc.lineTo(shapePath[i][0], shapePath[i][1]);
                            }
                            doc.lineTo(shapePath[0][0], shapePath[0][1]);
                            doc.stroke();
                        }

                        const baseFontSize = Math.max(5, 14 - (numPins / 40));
                        doc.setTextColor(0, 0, 0);

                        pinCoords.forEach((pin, i) => {
                            const x_abs = pin.x + margin;
                            const y_abs = pin.y + margin;
                            
                            const x = x_abs - offsetX;
                            const y = y_abs - offsetY;

                            if (x >= margin && x <= a4_width_in - margin && y >= margin && y <= a4_height_in - margin) {
                                doc.circle(x, y, 0.03, 'F');
                                
                                const angle = Math.atan2((pin.y) - heightIn / 2, (pin.x) - widthIn / 2);
                                
                                const label = getPinLabelForPdf(i);
                                const isAlpha = isNaN(parseInt(label));

                                const fontSize = isAlpha ? baseFontSize + 2 : baseFontSize;
                                doc.setFontSize(fontSize);
                                doc.setFont(undefined, isAlpha ? 'bold' : 'normal');

                                const textOffset = 0.12;
                                const textX = x + textOffset * Math.cos(angle);
                                const textY = y + textOffset * Math.sin(angle);
                                
                                doc.text(label, textX, textY, { align: 'center', baseline: 'middle' });
                            }
                        });
                        
                        doc.setFontSize(8);
                        doc.setTextColor(150, 150, 150);
                        doc.text(`Row ${r + 1}, Col ${c + 1}`, margin, margin - 0.1);
                    }
                }

                doc.save(`string-art-template-${currentShape}.pdf`);
            }
        });
    </script>
</body>
</html>
